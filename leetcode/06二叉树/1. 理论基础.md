<h4 id="SBxwh">种类</h4>
<h5 id="hgWlW">满二叉树</h5>

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。也可以说深度为k，有2^k-1个节点的二叉树  
![](http://cdn.notes.kamacoder.com/3057af3f-2081-464c-94cb-bb2920c44cff.png)

<h5 id="M8o77">完全二叉树</h5>

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。  
![](http://cdn.notes.kamacoder.com/898d2d07-575d-45e5-bef7-689324bb08bf.png)

满二叉树就是完全二叉树。

优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

<h5 id="WVOqM">二叉搜索树</h5>

满二叉树和完全二叉树都是没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。

+ 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
+ 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
+ 它的左、右子树也分别为二叉排序树  
![](http://cdn.notes.kamacoder.com/a1f57947-4f58-43ad-8a35-372f0e4d6676.png)

<h5 id="XQfyJ">平衡二叉搜索树（AVL）</h5>

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  
![](http://cdn.notes.kamacoder.com/03700e76-e0a3-4a11-8235-693b4fcfc6a6.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（表现为它们的 key 都是 有序的），所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

<h4 id="TZGn2">存储</h4>

二叉树可以链式存储，也可以顺序存储。

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

**链式存储**  
![](http://cdn.notes.kamacoder.com/c15558b2-760a-4989-b1b3-1efcf75b6cfe.png)

**顺序存储**  
![](http://cdn.notes.kamacoder.com/da25ad60-9c5b-4a6f-b04f-177de5a45039.png)  
用数组来存储二叉树如何遍历的呢？

如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

<h4 id="ygBtW">遍历方式</h4>

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
    - 前序遍历（中左右）（递归法，迭代法）
    - 中序遍历（左中右）（递归法，迭代法）
    - 后序遍历（左右中）（递归法，迭代法）
2. 广度优先遍历：一层一层的去遍历。
    - 层次遍历（迭代法）

![](http://cdn.notes.kamacoder.com/93581e9e-916e-4568-bb9b-51604f073b4c.png)

之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说**前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的**。

而**广度优先遍历的实现一般使用队列来实现**，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

<h4 id="vo3fc">定义</h4>

顺序存储就是用数组来存。

链式存储的二叉树节点的定义方式：

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

